{"name":"Srinivas Kommu Tech Blog","tagline":"Passionate About Infomation","body":"### Software maintenance with Good Design\r\nIn software engineer life involvement in implementing the software applications and maintaining over the time is obvious thing.  The people who involves in maintaining the application can be a new team member who joined recently who doesn’t have any idea about the application, some times same set of engineers who involved in developing the application or it could be different group of engineers.  But how a team member or entire team enjoys maintaining the application depends on the software engineering principles that team followed while design, implementation and also current phase of maintaining the application.   \r\n\r\nThe term software maintenance refers to changes for defect correction, performance improvements, or adaptations to changed business requirements.  Change or enhancement to software could introduce a new bug in existing working software. With the poor design/code implementation in existing application could demand almost redesigning/rewriting the whole software that will be more costly.  That could lead the same kind of process in the future also whenever we required a code change. Most software maintenance requirements could have been anticipated and avoided during the design process.  In other words, maintenance is a form of waste. Adhere to best software engineering principles like SOLID principles while designing or implementing the code can save our lives while maintaining the software over the course of time. \r\n\r\nI was given a task of maintaining poorly written application called gilded Rose. The problem description can be found at - [gilded-rose-refactoring-kata](https://github.com/NotMyself/GildedRose#gilded-rose-refactoring-kata/).  As part of the maintenance of current code and also there was new requirement (below description) from business, which made me to refactor the existing code. \r\n\r\n“We have recently signed a supplier of conjured items. This requires an update to our system: \"Conjured\" items degrade in Quality twice as fast as normal items”\r\n\r\nWhile thinking about changing the existing code, I was thinking how to make this application code easy to maintain over time and defect-free, performs well, and to contain user-controlled parameters to adjust processing rules in response to changing requirements. While refactoring the code, I was afraid to touch even single line of code; my fear was it might break the existing functionality.  I lost figuring out where to change the code; I also attempted to rewrite the entire code few times. This drove me to write all test cases for the existing functionality before touching any application code.  I written test case that covers existing functionality and those tests gave me confidence to change code.\r\n\r\nMain thing came to my mind is the ‘Sprout’ class for new item ‘Conjured’ with ‘ Test Driven Development ’. So started writing test case for ‘Conjured’ item and also ‘ConJureItem’.  I successfully updated the main program ‘Gilded Rose’ with if condition and my earlier tests with new ConjuredItem test passing.\r\n\r\n##ConjuredItem\r\npublic class ConjuredItem extends ItemWrapper\r\n{\r\n  public ConjuredItem(String name, int sellIn, int quality)\r\n  {\r\n    super(name, sellIn, quality);\r\n\r\n  }\r\n\r\n\r\n  @Override\r\n  public void updateQuality()\r\n  {\r\n    if (super.getQuality() - 1 >= 0)\r\n    {\r\n      if (super.getSellIn() > 0)\r\n      {\r\n        super.setQuality(super.getQuality() - 2);\r\n      }\r\n      else\r\n      {\r\n        super.setQuality(super.getQuality() - 4);\r\n      }\r\n\r\n    }\r\n\r\n  }\r\n}\r\n##Change to main program\r\n\r\npublic void updateQuality() {\r\n        for (int i = 0; i < items.length; i++) {\r\n\t\tif (items[i].name.equals(\"Conjured\"){\r\n\t\t\titems[i].quality = new ConjuredItem(items[i].name, items[i].sellIn, items[i].quality).updateQuality();\r\n        \t\t\r\n        \t}\r\n\r\nWith the above change all my test cases were passing along with new Conjure Item test as well.  After I finished the new requirement I started observing for ‘code smells’ with the lines of good design including the Object-Oriented paradigm  and SOLID (S: Single Responsibility Principle (SRP), O: Open-Closed Principle (OCP), L: Liskov Substitution Principle (LSP), I: Interface Segregation Principle (ISP), D: Dependency Inversion Principle (DIP)) principles for simple design.\r\n\r\n###Code smells and effects in current code:\r\n•\tLarge Class and long method are difficult to read, understand, and troubleshoot. \r\n•\tConditional Complexity\t\r\n•\tCode repetition and Combinatorial Explosion. (DRY: Don't Repeat Yourself) lots of code that does almost the same thing.\r\n\r\n###Code refactoring:\r\n\r\n•\tPre written test cases for all possible scenarios gave me quick feedback on my code refactoring.  \r\n•\tI went on refactoring piece by piece until I felt like code looks modular, easy to change, understandable and follows SOLID  principles.\r\n•\tI figured SRP and OCP were violated\r\no\tSRP: Class should have one and only one reason to change\r\no\tOCP: Open for extension and closed for modification\r\n•\tI created ‘ItemControl’ abstraction and subclasses for each Item Type implementing ‘Item Control’ based SRP and OCP principle.\r\n•\tEven if we add new category of item in the future, we will add one more sub type by extending the ‘Item Control’ abstraction instead of modifying it.\r\n•\tThere is special Item ‘Sulfar’, which doesn’t fall under updating ‘quality’ and ‘sellIn’, So I observed that If I extend ‘ItemControl’, there is possibility for violation of Interface Segregation Principle (ISP).\r\no\tISP states that clients should not be forced to implement interfaces they don't use.\r\n\r\n\r\nMy refactored code is available for review [code](https://github.com/srinivaskommu/codekatas). So with good design we will achieve the highly readable, testable, defect free code and easy to adjust processing rules in response to changing requirements. This will lead to easy maintenance of the delivered product over time. ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}